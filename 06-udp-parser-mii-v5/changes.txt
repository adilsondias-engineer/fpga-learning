a concise hardening pass to make the design robust and remove the remaining edge cases.

### 1) RX-domain reset and in-frame gating
- Use a reset synchronized to `eth_rx_clk` for all RX-domain modules.
- Feed `ip_parser.frame_valid` with an in-frame flag (between `frame_start` and `frame_end`).

```vhdl
-- RX-domain reset synchronizer
signal mdio_rst_rxclk_sync1, mdio_rst_rxclk_sync2 : std_logic := '1';
signal mdio_rst_rxclk : std_logic;

process(eth_rx_clk)
begin
    if rising_edge(eth_rx_clk) then
        mdio_rst_rxclk_sync1 <= mdio_rst;
        mdio_rst_rxclk_sync2 <= mdio_rst_rxclk_sync1;
    end if;
end process;
mdio_rst_rxclk <= mdio_rst_rxclk_sync2;

-- In-frame flag
signal in_frame : std_logic := '0';
process(eth_rx_clk)
begin
    if rising_edge(eth_rx_clk) then
        if mdio_rst_rxclk = '1' then
            in_frame <= '0';
        else
            if frame_start = '1' then
                in_frame <= '1';
            elsif frame_end = '1' then
                in_frame <= '0';
            end if;
        end if;
    end if;
end process;
```

Wire RX-domain modules with this reset and `frame_valid => in_frame`.

### 2) IP parser: stay in PARSE_HEADER and exit cleanly
- You already fixed the “jump-to-VALIDATE” bug. Add early exit if the frame ends mid-header.

```vhdl
when PARSE_HEADER =>
    if frame_valid = '0' then
        -- abort header cleanly
        header_byte_count <= 0;
        checksum_acc <= (others => '0');
        state <= IDLE;
    elsif byte_index = 14 + header_byte_count then
        -- [your corrected latching for fields and checksum...]
        header_byte_count <= header_byte_count + 1;
        if header_byte_count = 19 then
            state <= VALIDATE;
            validate_step <= 0;
        end if;
    else
        null; -- wait for matching index
    end if;
```

### 3) Proper CDC (multi-bit latch on synchronized pulses)
- Latch multi-bit IP/UDP buses in 100 MHz on synchronized valid pulses; feed UART and stats from these shadow regs.

```vhdl
-- 100 MHz domain
signal ip_src_sync, ip_dst_sync : std_logic_vector(31 downto 0) := (others => '0');
signal ip_total_length_sync     : std_logic_vector(15 downto 0) := (others => '0');
signal ip_version_ihl_byte_sync : std_logic_vector(7 downto 0)  := (others => '0');

process(clk)
begin
    if rising_edge(clk) then
        if reset = '1' then
            ip_valid_sync1 <= '0'; ip_valid_sync2 <= '0';
            ip_protocol_sync1 <= (others => '0'); ip_protocol_sync2 <= (others => '0');
            ip_checksum_ok_sync1 <= '0'; ip_checksum_ok_sync2 <= '0';
            ip_version_err_sync1 <= '0'; ip_version_err_sync2 <= '0';
            ip_ihl_err_sync1 <= '0'; ip_ihl_err_sync2 <= '0';
            ip_checksum_err_sync1 <= '0'; ip_checksum_err_sync2 <= '0';
            ip_src_sync <= (others => '0'); ip_dst_sync <= (others => '0');
            ip_total_length_sync <= (others => '0'); ip_version_ihl_byte_sync <= (others => '0');
        else
            ip_valid_sync1 <= ip_valid; ip_valid_sync2 <= ip_valid_sync1;
            ip_checksum_ok_sync1 <= ip_checksum_ok; ip_checksum_ok_sync2 <= ip_checksum_ok_sync1;
            ip_version_err_sync1 <= ip_version_err; ip_version_err_sync2 <= ip_version_err_sync1;
            ip_ihl_err_sync1 <= ip_ihl_err; ip_ihl_err_sync2 <= ip_ihl_err_sync1;
            ip_checksum_err_sync1 <= ip_checksum_err; ip_checksum_err_sync2 <= ip_checksum_err_sync1;

            if ip_valid_sync1 = '1' then
                ip_protocol_sync1 <= ip_protocol;
                ip_version_ihl_byte_sync <= ip_version_ihl_byte;
                ip_src_sync <= ip_src;
                ip_dst_sync <= ip_dst;
                ip_total_length_sync <= ip_total_length;
            end if;
            ip_protocol_sync2 <= ip_protocol_sync1;
        end if;
    end if;
end process;

-- Use the synchronized copies for uart_formatter/stats
-- ip_protocol => ip_protocol_sync2
-- ip_src      => ip_src_sync
-- ip_dst      => ip_dst_sync
-- ip_total_length => ip_total_length_sync
-- ip_version_ihl_byte => ip_version_ihl_byte_sync
-- ip_*_err/ok => *_sync2
```

Do the same for UDP: 2FF sync for single-bit `udp_valid` and `udp_length_err`; latch `udp_src_port/udp_dst_port` on `udp_valid_sync1 = '1'`.

### 4) UART formatter inputs
Ensure it’s connected to the synchronized signals (not raw RX-domain). In `mii_eth_top.vhd`:

```vhdl
ip_protocol     => ip_protocol_sync2,
ip_src          => ip_src_sync,
ip_dst          => ip_dst_sync,
ip_total_length => ip_total_length_sync,
ip_checksum_ok  => ip_checksum_ok_sync2,
ip_version_err  => ip_version_err_sync2,
ip_ihl_err      => ip_ihl_err_sync2,
ip_checksum_err => ip_checksum_err_sync2,
ip_version_ihl_byte => ip_version_ihl_byte_sync,

udp_src_port    => udp_src_port_sync,
udp_dst_port    => udp_dst_port_sync,
udp_length      => udp_length,
udp_checksum_ok => udp_checksum_ok,
udp_length_err  => udp_length_err_sync2,
```

### 5) XDC constraints: CDC hygiene
Add attributes and constraints to guide timing.

```xdc
# Clocks
create_clock -name sys_clk -period 10.000 [get_ports CLK]
create_clock -name eth_rx_clk -period 40.000 [get_ports eth_rx_clk]

# Declare async clock groups (handled via synchronizers)
set_clock_groups -asynchronous -group {sys_clk} -group {eth_rx_clk}

# Mark synchronizer flops (example; adjust cell names)
set_property ASYNC_REG TRUE [get_cells -hier *ip_valid_sync*]
set_property ASYNC_REG TRUE [get_cells -hier *udp_valid_sync*]
set_false_path -to [get_cells -hier *ip_valid_sync1*]
set_false_path -to [get_cells -hier *udp_valid_sync1*]
```

### 6) Small sanity checks
- `mac_parser.frame_valid` is a one-cycle pulse at end-of-frame by design; using `in_frame` for the IP parser is correct.
- Ensure all RX-domain modules (`mii_rx`, `mac_parser`, `ip_parser`, `udp_parser`) use `mdio_rst_rxclk`.
- Keep `ip_valid` and `udp_valid` as one-cycle pulses (already the case).

That’s it. With these in place, you should see stable IP (b14=45), correct flags, and clean UDP reporting across bursts and mixed traffic.
